# 线性表

标签：数据结构和算法

---

## 线性表
线性表是最简单和常用的一种数据结构，是有限个数据元素组成的序列。同一线性表中的数据元素必须具有相同的特性，也就是数据元素的类型需要一样。具体的抽象数据类型(ADT)表示如下：    

    ADT List {
        D: element_n; // 每个数据元素
        S: //每个数据元素有自己的确定的位置
        P:
            init_list(&l);  // 初始化一个序列
            destroy_list(&l);   // 销毁一个序列
            clear_list(&l);     // 置空一个序列
            empty(l);           // 判断序列是否为空
            length(l);          // 序列中的数据元素个数
            get(l, i, &e); // 序列中位置i上的数据元素e
            locate(l, e); // 定位元素e
            insert(&l, i, e); // 序列位置i上插入数据元素e
            remove(&l, i, &e); // 序列位置i上删除数据元素，并且利用e返回值
    }

## 线性表的顺序表示
顺序表示就是用一组地址连续的存储单元依次存储线性表的数据元素。通常来说就是数组。

    // 线性表的顺序表示
    #define INIT_SIZE 10   // 初始分配量
    #define INCREASE_SIZE 10 // 增量分配量
    typedef struct {
        element_type *_element;  // 动态存储的首地址
        int _size; // 存储数据元素的个数
        int _alloc_size; // 当前分配的大小
    }SeqList;
    
> 顺序表示的特征
> 查找比较快，由于数据元素是连续存储的，因此查找只需要知道数据元素索引，根据地址偏移很快就能查找到；
> 增删比较慢，由于在指定位置新增的时候，该位置以及以后的元素通通都要后移一位；删除也是同理。

## 线性表的链式表示
从上一小节示例[代码](https://github.com/pengqiang-gs/algorithms/chapter02/)可以看出，线性表的顺序存储结构不仅是逻辑关系数据元素之间相邻，物理存储上也采用连续存储，这种结构的最大弱点：在插入和删除数据元素的时候，需要移动大量的数据节点。因此线性表的另一种存储方法-链式存储应运而生。 

### 单向链表
线性表的链式存储结构是用一组任意的存储单元存储线性表的数据元素，这些存储单元不要求是存储地址连续，但是每个存储元素除了存储本身的信息之外，还需要存储一个指示其后继数据元素的指针（称之为节点）。

    typedef struct node{
        type _element;          // 数据域，存储数据元素信息
        struct node* _next;     // 指针域，指向下一个数据节点
    }node;

单向链表就是一个`header`的节点开始：
    
    typedef struct {
        node* _header;          // 记录链表的头指针
        int _size;              // 记录链表的元素记录数
    }list;
    
单向链表一般还会附设一个头节点（head），头节点的数据域可以不放任何信息，当然也可以放和链表有关系的其他的东西（比如链表的长度），头节点指针域如果为空，则该链表长度为`0`.    
链表由于数据元素的存储不是连续的，因此不能按照顺序存储的那样随机存取，只能从头指针出发，一路通过`next`才能找到，因此链式存储对于数据元素的访问效率很低。

### 双向链表
单向链表中，获取位置`pos`上的元素的时间复杂度是`O(n)`，获取下一个元素（直接`next`就可以获取）的时间复杂度是`O(1)`，获取上一个元素（需要从`header`出发再去遍历`pos-1`个节点）的时间复杂度是`O(n)`。鉴于以上的原因，**双向链表**产生了。

    typedef struct node{
        type _element;              // 节点数据域
        struct node* _previous;     // 节点向前指针域
        struct node* _next;         // 节点向后指针域
    }node;
    
链表同上面单向链表一样，也是以一个`header`的节点开头：

    typedef struct {
        node* _header;              // 链表头节点
        int _size;                  // 链表的元素个数
    }list;

## 练习程序
练习程序[代码](https://github.com/pengqiang-gs/algorithms/chapter02/)
> - 线性表的顺序存储实现
> int_seq_list        
> - 线性表的单向链表实现
> int_single_list
> - 线性表的双向链表实现
> int_double_list

