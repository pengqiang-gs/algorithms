# 需要学习的东西

## 数据结构

> 一般来说，用计算机解决一个具体的问题时，大概需要经过以下几个步骤：
> 1. 从具体问题中抽象出一个适当的数据模型；
> 2. 设计一个能解此数据模型的算法；
> 3. 编写程序，运行出答案，直到最后问题解答完毕。
    
- 数据结构
  相互之间存在一种或者多种特定关系的数据元素的集合。    

- 存储结构
  数据结构再计算机中的存储。

**任何一个算法的设计取决于选定的数据结构，而算法的实现依赖于采用的存储结构。**

## 算法和算法分析
### 算法
算法（algorithm）是为求解一个问题需要遵循的，被清楚的指定的简单指令的集合。
### 算法分析
对于一个问题，一旦给定某种算法并且确定是正确的，那么剩余的工作就是确定该算法执行时需要多少的时间和空间资源。估算这种资源的方法就叫算法分析。

### 分析估算
- 如果存在正常数$c$和$n_0$，使得当$N \geq n_0$时$T(N) \leq cf(N)$，则记为$T(N) = O(f(N))$，称函数$f(N)$是函数$T(N)$的上界（upper bound）

- 如果存在正常数$c$和$n_0$，使得当$N \geq n_0$时$T(N) \geq cf(N)$，则记为$T(N) = \Omega(f(N))$，称函数$f(N)$是函数$T(N)$的下界（lower bound）

- 当且仅当$T(N) = O(f(N))$且$T(N) = \Omega(f(N))$时，记为$T(N) = \Theta(f(N))$

- 如果$T(N) = O(f(N))$且$T(N) \not= \Theta(f(N))$时，记为$T(N) = o(f(N))$

- 如果$T_1(N) = O(f(N))$且$T_2(N) = O(g(N))$，则
> - $T_1(N)+T_2(N) = max(O(f(N)), O(g(N)))$
> - $T_1(N) \times T_2(N) = O(f(N) \times g(N))$

- 如果$T(N)$是一个$k$次多项式，则$T(N) = \Theta(N^k)$

- 对于任意常数$k$，$log^kN = O(N)$，即对数增长的非常缓慢，慢于常数

## 抽象数据类型
抽象数据类型(abstract data type, ADT)是指一个数据模型以及定义在该模型上的一组操作。抽象数据类型的定义仅取决于它的一组逻辑特性，而与其在计算机内部如何表示和实现无关，也就是不论其内部结构如何变化，只要它的数据特性不变，都不影响其外部的使用。    

抽象数据类型的DSP表示：    
    
    ADT 抽象数据类型名称 {
        D; // 数据对象的定义
        S; // 数据关系的定义
        P; // 数据操作的定义
    } ADT 抽象数据类型名称;

## 算法
算法(algorithm)时对特定问题求解步骤的一种描述，是指令的有限序列，其中对每一条指令表示一个或者多个操作。

> 算法的特征：
>> - 有穷性
>> 一个算法必须是再执行有穷步骤之后结束，并且每一个都在有穷时间内结束。
>> - 确定性
>> 一个算法在每一步都有确定的含义，不会产生二义性。在任何情况下，算法直有唯一的一条执行路径，对于相同的输入可以得到确定的相同的输出。
>> - 可行性
>> 一个算法中描述的操作都是可以通过已经实现的基本运算执行有限次数来实现。
>> - 输入输出
>> 一个算法有0个或者多个输入；一个算法至少有一个输出。

> 算法设计的要求：
>> - 正确性
>> 对于正确的输入可以得到正确的输出。
>> - 可读性
>> 一个算法只要还是人解决问题的思路，也就是主要是与人交流，可读性必须要好。
>> - 健壮性
>> 一个算法当输入非法时也能进行有效地规避，不会产生莫名奇妙的输出或者导致宕机等结果。
>>- 效率和存储需求
>> 一个算法当明确有执行效率或者存储空间的约束时，看算法运行时是否满足需求。

## 算法分析
这地方算法分析写的有点简单，只记录了两个渐进符号。具体分析算法的地方可以参考[算法导论公开课](http://open.163.com/movie/2010/12/2/E/M6UTT5U0I_M6V2T4T2E.html)。    

- 渐进时间复杂度
$T(n) = O(f(n))$
- 渐进空间复杂度
$S(n) =O(f(n))$
